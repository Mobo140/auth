// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Mobo140/microservices/auth/internal/repository.UserDBRepository -o user_db_repository_minimock.go -n UserDBRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Mobo140/microservices/auth/internal/model"
	"github.com/gojuno/minimock/v3"
)

// UserDBRepositoryMock implements mm_repository.UserDBRepository
type UserDBRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, user *model.User) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, user *model.User)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mUserDBRepositoryMockCreate

	funcDelete          func(ctx context.Context, id int64) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mUserDBRepositoryMockDelete

	funcGet          func(ctx context.Context, id int64) (up1 *model.UserInfo, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mUserDBRepositoryMockGet

	funcGetUsers          func(ctx context.Context, params *model.GetUsersRequest) (upa1 []*model.UserInfo, err error)
	funcGetUsersOrigin    string
	inspectFuncGetUsers   func(ctx context.Context, params *model.GetUsersRequest)
	afterGetUsersCounter  uint64
	beforeGetUsersCounter uint64
	GetUsersMock          mUserDBRepositoryMockGetUsers

	funcUpdate          func(ctx context.Context, id int64, userInfo *model.UpdateUserInfo) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, id int64, userInfo *model.UpdateUserInfo)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mUserDBRepositoryMockUpdate
}

// NewUserDBRepositoryMock returns a mock for mm_repository.UserDBRepository
func NewUserDBRepositoryMock(t minimock.Tester) *UserDBRepositoryMock {
	m := &UserDBRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mUserDBRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*UserDBRepositoryMockCreateParams{}

	m.DeleteMock = mUserDBRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*UserDBRepositoryMockDeleteParams{}

	m.GetMock = mUserDBRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*UserDBRepositoryMockGetParams{}

	m.GetUsersMock = mUserDBRepositoryMockGetUsers{mock: m}
	m.GetUsersMock.callArgs = []*UserDBRepositoryMockGetUsersParams{}

	m.UpdateMock = mUserDBRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*UserDBRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserDBRepositoryMockCreate struct {
	optional           bool
	mock               *UserDBRepositoryMock
	defaultExpectation *UserDBRepositoryMockCreateExpectation
	expectations       []*UserDBRepositoryMockCreateExpectation

	callArgs []*UserDBRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserDBRepositoryMockCreateExpectation specifies expectation struct of the UserDBRepository.Create
type UserDBRepositoryMockCreateExpectation struct {
	mock               *UserDBRepositoryMock
	params             *UserDBRepositoryMockCreateParams
	paramPtrs          *UserDBRepositoryMockCreateParamPtrs
	expectationOrigins UserDBRepositoryMockCreateExpectationOrigins
	results            *UserDBRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// UserDBRepositoryMockCreateParams contains parameters of the UserDBRepository.Create
type UserDBRepositoryMockCreateParams struct {
	ctx  context.Context
	user *model.User
}

// UserDBRepositoryMockCreateParamPtrs contains pointers to parameters of the UserDBRepository.Create
type UserDBRepositoryMockCreateParamPtrs struct {
	ctx  *context.Context
	user **model.User
}

// UserDBRepositoryMockCreateResults contains results of the UserDBRepository.Create
type UserDBRepositoryMockCreateResults struct {
	i1  int64
	err error
}

// UserDBRepositoryMockCreateOrigins contains origins of expectations of the UserDBRepository.Create
type UserDBRepositoryMockCreateExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mUserDBRepositoryMockCreate) Optional() *mUserDBRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for UserDBRepository.Create
func (mmCreate *mUserDBRepositoryMockCreate) Expect(ctx context.Context, user *model.User) *mUserDBRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserDBRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserDBRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("UserDBRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &UserDBRepositoryMockCreateParams{ctx, user}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for UserDBRepository.Create
func (mmCreate *mUserDBRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mUserDBRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserDBRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserDBRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserDBRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserDBRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectUserParam2 sets up expected param user for UserDBRepository.Create
func (mmCreate *mUserDBRepositoryMockCreate) ExpectUserParam2(user *model.User) *mUserDBRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserDBRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserDBRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("UserDBRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &UserDBRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.user = &user
	mmCreate.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the UserDBRepository.Create
func (mmCreate *mUserDBRepositoryMockCreate) Inspect(f func(ctx context.Context, user *model.User)) *mUserDBRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for UserDBRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by UserDBRepository.Create
func (mmCreate *mUserDBRepositoryMockCreate) Return(i1 int64, err error) *UserDBRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserDBRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &UserDBRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &UserDBRepositoryMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the UserDBRepository.Create method
func (mmCreate *mUserDBRepositoryMockCreate) Set(f func(ctx context.Context, user *model.User) (i1 int64, err error)) *UserDBRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the UserDBRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the UserDBRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the UserDBRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mUserDBRepositoryMockCreate) When(ctx context.Context, user *model.User) *UserDBRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("UserDBRepositoryMock.Create mock is already set by Set")
	}

	expectation := &UserDBRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &UserDBRepositoryMockCreateParams{ctx, user},
		expectationOrigins: UserDBRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up UserDBRepository.Create return parameters for the expectation previously defined by the When method
func (e *UserDBRepositoryMockCreateExpectation) Then(i1 int64, err error) *UserDBRepositoryMock {
	e.results = &UserDBRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times UserDBRepository.Create should be invoked
func (mmCreate *mUserDBRepositoryMockCreate) Times(n uint64) *mUserDBRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of UserDBRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mUserDBRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.UserDBRepository
func (mmCreate *UserDBRepositoryMock) Create(ctx context.Context, user *model.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, user)
	}

	mm_params := UserDBRepositoryMockCreateParams{ctx, user}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := UserDBRepositoryMockCreateParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("UserDBRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmCreate.t.Errorf("UserDBRepositoryMock.Create got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("UserDBRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the UserDBRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, user)
	}
	mmCreate.t.Fatalf("Unexpected call to UserDBRepositoryMock.Create. %v %v", ctx, user)
	return
}

// CreateAfterCounter returns a count of finished UserDBRepositoryMock.Create invocations
func (mmCreate *UserDBRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of UserDBRepositoryMock.Create invocations
func (mmCreate *UserDBRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to UserDBRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mUserDBRepositoryMockCreate) Calls() []*UserDBRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*UserDBRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *UserDBRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *UserDBRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserDBRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserDBRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserDBRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to UserDBRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to UserDBRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mUserDBRepositoryMockDelete struct {
	optional           bool
	mock               *UserDBRepositoryMock
	defaultExpectation *UserDBRepositoryMockDeleteExpectation
	expectations       []*UserDBRepositoryMockDeleteExpectation

	callArgs []*UserDBRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserDBRepositoryMockDeleteExpectation specifies expectation struct of the UserDBRepository.Delete
type UserDBRepositoryMockDeleteExpectation struct {
	mock               *UserDBRepositoryMock
	params             *UserDBRepositoryMockDeleteParams
	paramPtrs          *UserDBRepositoryMockDeleteParamPtrs
	expectationOrigins UserDBRepositoryMockDeleteExpectationOrigins
	results            *UserDBRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// UserDBRepositoryMockDeleteParams contains parameters of the UserDBRepository.Delete
type UserDBRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// UserDBRepositoryMockDeleteParamPtrs contains pointers to parameters of the UserDBRepository.Delete
type UserDBRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserDBRepositoryMockDeleteResults contains results of the UserDBRepository.Delete
type UserDBRepositoryMockDeleteResults struct {
	err error
}

// UserDBRepositoryMockDeleteOrigins contains origins of expectations of the UserDBRepository.Delete
type UserDBRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mUserDBRepositoryMockDelete) Optional() *mUserDBRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for UserDBRepository.Delete
func (mmDelete *mUserDBRepositoryMockDelete) Expect(ctx context.Context, id int64) *mUserDBRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserDBRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserDBRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("UserDBRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &UserDBRepositoryMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for UserDBRepository.Delete
func (mmDelete *mUserDBRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mUserDBRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserDBRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserDBRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserDBRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserDBRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for UserDBRepository.Delete
func (mmDelete *mUserDBRepositoryMockDelete) ExpectIdParam2(id int64) *mUserDBRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserDBRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserDBRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("UserDBRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &UserDBRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the UserDBRepository.Delete
func (mmDelete *mUserDBRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mUserDBRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for UserDBRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by UserDBRepository.Delete
func (mmDelete *mUserDBRepositoryMockDelete) Return(err error) *UserDBRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserDBRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &UserDBRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &UserDBRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the UserDBRepository.Delete method
func (mmDelete *mUserDBRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *UserDBRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the UserDBRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the UserDBRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the UserDBRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUserDBRepositoryMockDelete) When(ctx context.Context, id int64) *UserDBRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("UserDBRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &UserDBRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &UserDBRepositoryMockDeleteParams{ctx, id},
		expectationOrigins: UserDBRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up UserDBRepository.Delete return parameters for the expectation previously defined by the When method
func (e *UserDBRepositoryMockDeleteExpectation) Then(err error) *UserDBRepositoryMock {
	e.results = &UserDBRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times UserDBRepository.Delete should be invoked
func (mmDelete *mUserDBRepositoryMockDelete) Times(n uint64) *mUserDBRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of UserDBRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mUserDBRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.UserDBRepository
func (mmDelete *UserDBRepositoryMock) Delete(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := UserDBRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := UserDBRepositoryMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("UserDBRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("UserDBRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("UserDBRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the UserDBRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to UserDBRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished UserDBRepositoryMock.Delete invocations
func (mmDelete *UserDBRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of UserDBRepositoryMock.Delete invocations
func (mmDelete *UserDBRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to UserDBRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUserDBRepositoryMockDelete) Calls() []*UserDBRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*UserDBRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UserDBRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UserDBRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserDBRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserDBRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserDBRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to UserDBRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to UserDBRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mUserDBRepositoryMockGet struct {
	optional           bool
	mock               *UserDBRepositoryMock
	defaultExpectation *UserDBRepositoryMockGetExpectation
	expectations       []*UserDBRepositoryMockGetExpectation

	callArgs []*UserDBRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserDBRepositoryMockGetExpectation specifies expectation struct of the UserDBRepository.Get
type UserDBRepositoryMockGetExpectation struct {
	mock               *UserDBRepositoryMock
	params             *UserDBRepositoryMockGetParams
	paramPtrs          *UserDBRepositoryMockGetParamPtrs
	expectationOrigins UserDBRepositoryMockGetExpectationOrigins
	results            *UserDBRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// UserDBRepositoryMockGetParams contains parameters of the UserDBRepository.Get
type UserDBRepositoryMockGetParams struct {
	ctx context.Context
	id  int64
}

// UserDBRepositoryMockGetParamPtrs contains pointers to parameters of the UserDBRepository.Get
type UserDBRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserDBRepositoryMockGetResults contains results of the UserDBRepository.Get
type UserDBRepositoryMockGetResults struct {
	up1 *model.UserInfo
	err error
}

// UserDBRepositoryMockGetOrigins contains origins of expectations of the UserDBRepository.Get
type UserDBRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mUserDBRepositoryMockGet) Optional() *mUserDBRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for UserDBRepository.Get
func (mmGet *mUserDBRepositoryMockGet) Expect(ctx context.Context, id int64) *mUserDBRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserDBRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserDBRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("UserDBRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &UserDBRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for UserDBRepository.Get
func (mmGet *mUserDBRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mUserDBRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserDBRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserDBRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserDBRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserDBRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for UserDBRepository.Get
func (mmGet *mUserDBRepositoryMockGet) ExpectIdParam2(id int64) *mUserDBRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserDBRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserDBRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("UserDBRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &UserDBRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the UserDBRepository.Get
func (mmGet *mUserDBRepositoryMockGet) Inspect(f func(ctx context.Context, id int64)) *mUserDBRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for UserDBRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by UserDBRepository.Get
func (mmGet *mUserDBRepositoryMockGet) Return(up1 *model.UserInfo, err error) *UserDBRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserDBRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &UserDBRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &UserDBRepositoryMockGetResults{up1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the UserDBRepository.Get method
func (mmGet *mUserDBRepositoryMockGet) Set(f func(ctx context.Context, id int64) (up1 *model.UserInfo, err error)) *UserDBRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the UserDBRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the UserDBRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the UserDBRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mUserDBRepositoryMockGet) When(ctx context.Context, id int64) *UserDBRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("UserDBRepositoryMock.Get mock is already set by Set")
	}

	expectation := &UserDBRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &UserDBRepositoryMockGetParams{ctx, id},
		expectationOrigins: UserDBRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up UserDBRepository.Get return parameters for the expectation previously defined by the When method
func (e *UserDBRepositoryMockGetExpectation) Then(up1 *model.UserInfo, err error) *UserDBRepositoryMock {
	e.results = &UserDBRepositoryMockGetResults{up1, err}
	return e.mock
}

// Times sets number of times UserDBRepository.Get should be invoked
func (mmGet *mUserDBRepositoryMockGet) Times(n uint64) *mUserDBRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of UserDBRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mUserDBRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.UserDBRepository
func (mmGet *UserDBRepositoryMock) Get(ctx context.Context, id int64) (up1 *model.UserInfo, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := UserDBRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := UserDBRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("UserDBRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("UserDBRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("UserDBRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the UserDBRepositoryMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to UserDBRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished UserDBRepositoryMock.Get invocations
func (mmGet *UserDBRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of UserDBRepositoryMock.Get invocations
func (mmGet *UserDBRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to UserDBRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mUserDBRepositoryMockGet) Calls() []*UserDBRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*UserDBRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *UserDBRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *UserDBRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserDBRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserDBRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserDBRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to UserDBRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to UserDBRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mUserDBRepositoryMockGetUsers struct {
	optional           bool
	mock               *UserDBRepositoryMock
	defaultExpectation *UserDBRepositoryMockGetUsersExpectation
	expectations       []*UserDBRepositoryMockGetUsersExpectation

	callArgs []*UserDBRepositoryMockGetUsersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserDBRepositoryMockGetUsersExpectation specifies expectation struct of the UserDBRepository.GetUsers
type UserDBRepositoryMockGetUsersExpectation struct {
	mock               *UserDBRepositoryMock
	params             *UserDBRepositoryMockGetUsersParams
	paramPtrs          *UserDBRepositoryMockGetUsersParamPtrs
	expectationOrigins UserDBRepositoryMockGetUsersExpectationOrigins
	results            *UserDBRepositoryMockGetUsersResults
	returnOrigin       string
	Counter            uint64
}

// UserDBRepositoryMockGetUsersParams contains parameters of the UserDBRepository.GetUsers
type UserDBRepositoryMockGetUsersParams struct {
	ctx    context.Context
	params *model.GetUsersRequest
}

// UserDBRepositoryMockGetUsersParamPtrs contains pointers to parameters of the UserDBRepository.GetUsers
type UserDBRepositoryMockGetUsersParamPtrs struct {
	ctx    *context.Context
	params **model.GetUsersRequest
}

// UserDBRepositoryMockGetUsersResults contains results of the UserDBRepository.GetUsers
type UserDBRepositoryMockGetUsersResults struct {
	upa1 []*model.UserInfo
	err  error
}

// UserDBRepositoryMockGetUsersOrigins contains origins of expectations of the UserDBRepository.GetUsers
type UserDBRepositoryMockGetUsersExpectationOrigins struct {
	origin       string
	originCtx    string
	originParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUsers *mUserDBRepositoryMockGetUsers) Optional() *mUserDBRepositoryMockGetUsers {
	mmGetUsers.optional = true
	return mmGetUsers
}

// Expect sets up expected params for UserDBRepository.GetUsers
func (mmGetUsers *mUserDBRepositoryMockGetUsers) Expect(ctx context.Context, params *model.GetUsersRequest) *mUserDBRepositoryMockGetUsers {
	if mmGetUsers.mock.funcGetUsers != nil {
		mmGetUsers.mock.t.Fatalf("UserDBRepositoryMock.GetUsers mock is already set by Set")
	}

	if mmGetUsers.defaultExpectation == nil {
		mmGetUsers.defaultExpectation = &UserDBRepositoryMockGetUsersExpectation{}
	}

	if mmGetUsers.defaultExpectation.paramPtrs != nil {
		mmGetUsers.mock.t.Fatalf("UserDBRepositoryMock.GetUsers mock is already set by ExpectParams functions")
	}

	mmGetUsers.defaultExpectation.params = &UserDBRepositoryMockGetUsersParams{ctx, params}
	mmGetUsers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUsers.expectations {
		if minimock.Equal(e.params, mmGetUsers.defaultExpectation.params) {
			mmGetUsers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUsers.defaultExpectation.params)
		}
	}

	return mmGetUsers
}

// ExpectCtxParam1 sets up expected param ctx for UserDBRepository.GetUsers
func (mmGetUsers *mUserDBRepositoryMockGetUsers) ExpectCtxParam1(ctx context.Context) *mUserDBRepositoryMockGetUsers {
	if mmGetUsers.mock.funcGetUsers != nil {
		mmGetUsers.mock.t.Fatalf("UserDBRepositoryMock.GetUsers mock is already set by Set")
	}

	if mmGetUsers.defaultExpectation == nil {
		mmGetUsers.defaultExpectation = &UserDBRepositoryMockGetUsersExpectation{}
	}

	if mmGetUsers.defaultExpectation.params != nil {
		mmGetUsers.mock.t.Fatalf("UserDBRepositoryMock.GetUsers mock is already set by Expect")
	}

	if mmGetUsers.defaultExpectation.paramPtrs == nil {
		mmGetUsers.defaultExpectation.paramPtrs = &UserDBRepositoryMockGetUsersParamPtrs{}
	}
	mmGetUsers.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUsers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUsers
}

// ExpectParamsParam2 sets up expected param params for UserDBRepository.GetUsers
func (mmGetUsers *mUserDBRepositoryMockGetUsers) ExpectParamsParam2(params *model.GetUsersRequest) *mUserDBRepositoryMockGetUsers {
	if mmGetUsers.mock.funcGetUsers != nil {
		mmGetUsers.mock.t.Fatalf("UserDBRepositoryMock.GetUsers mock is already set by Set")
	}

	if mmGetUsers.defaultExpectation == nil {
		mmGetUsers.defaultExpectation = &UserDBRepositoryMockGetUsersExpectation{}
	}

	if mmGetUsers.defaultExpectation.params != nil {
		mmGetUsers.mock.t.Fatalf("UserDBRepositoryMock.GetUsers mock is already set by Expect")
	}

	if mmGetUsers.defaultExpectation.paramPtrs == nil {
		mmGetUsers.defaultExpectation.paramPtrs = &UserDBRepositoryMockGetUsersParamPtrs{}
	}
	mmGetUsers.defaultExpectation.paramPtrs.params = &params
	mmGetUsers.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmGetUsers
}

// Inspect accepts an inspector function that has same arguments as the UserDBRepository.GetUsers
func (mmGetUsers *mUserDBRepositoryMockGetUsers) Inspect(f func(ctx context.Context, params *model.GetUsersRequest)) *mUserDBRepositoryMockGetUsers {
	if mmGetUsers.mock.inspectFuncGetUsers != nil {
		mmGetUsers.mock.t.Fatalf("Inspect function is already set for UserDBRepositoryMock.GetUsers")
	}

	mmGetUsers.mock.inspectFuncGetUsers = f

	return mmGetUsers
}

// Return sets up results that will be returned by UserDBRepository.GetUsers
func (mmGetUsers *mUserDBRepositoryMockGetUsers) Return(upa1 []*model.UserInfo, err error) *UserDBRepositoryMock {
	if mmGetUsers.mock.funcGetUsers != nil {
		mmGetUsers.mock.t.Fatalf("UserDBRepositoryMock.GetUsers mock is already set by Set")
	}

	if mmGetUsers.defaultExpectation == nil {
		mmGetUsers.defaultExpectation = &UserDBRepositoryMockGetUsersExpectation{mock: mmGetUsers.mock}
	}
	mmGetUsers.defaultExpectation.results = &UserDBRepositoryMockGetUsersResults{upa1, err}
	mmGetUsers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUsers.mock
}

// Set uses given function f to mock the UserDBRepository.GetUsers method
func (mmGetUsers *mUserDBRepositoryMockGetUsers) Set(f func(ctx context.Context, params *model.GetUsersRequest) (upa1 []*model.UserInfo, err error)) *UserDBRepositoryMock {
	if mmGetUsers.defaultExpectation != nil {
		mmGetUsers.mock.t.Fatalf("Default expectation is already set for the UserDBRepository.GetUsers method")
	}

	if len(mmGetUsers.expectations) > 0 {
		mmGetUsers.mock.t.Fatalf("Some expectations are already set for the UserDBRepository.GetUsers method")
	}

	mmGetUsers.mock.funcGetUsers = f
	mmGetUsers.mock.funcGetUsersOrigin = minimock.CallerInfo(1)
	return mmGetUsers.mock
}

// When sets expectation for the UserDBRepository.GetUsers which will trigger the result defined by the following
// Then helper
func (mmGetUsers *mUserDBRepositoryMockGetUsers) When(ctx context.Context, params *model.GetUsersRequest) *UserDBRepositoryMockGetUsersExpectation {
	if mmGetUsers.mock.funcGetUsers != nil {
		mmGetUsers.mock.t.Fatalf("UserDBRepositoryMock.GetUsers mock is already set by Set")
	}

	expectation := &UserDBRepositoryMockGetUsersExpectation{
		mock:               mmGetUsers.mock,
		params:             &UserDBRepositoryMockGetUsersParams{ctx, params},
		expectationOrigins: UserDBRepositoryMockGetUsersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUsers.expectations = append(mmGetUsers.expectations, expectation)
	return expectation
}

// Then sets up UserDBRepository.GetUsers return parameters for the expectation previously defined by the When method
func (e *UserDBRepositoryMockGetUsersExpectation) Then(upa1 []*model.UserInfo, err error) *UserDBRepositoryMock {
	e.results = &UserDBRepositoryMockGetUsersResults{upa1, err}
	return e.mock
}

// Times sets number of times UserDBRepository.GetUsers should be invoked
func (mmGetUsers *mUserDBRepositoryMockGetUsers) Times(n uint64) *mUserDBRepositoryMockGetUsers {
	if n == 0 {
		mmGetUsers.mock.t.Fatalf("Times of UserDBRepositoryMock.GetUsers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUsers.expectedInvocations, n)
	mmGetUsers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUsers
}

func (mmGetUsers *mUserDBRepositoryMockGetUsers) invocationsDone() bool {
	if len(mmGetUsers.expectations) == 0 && mmGetUsers.defaultExpectation == nil && mmGetUsers.mock.funcGetUsers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUsers.mock.afterGetUsersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUsers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUsers implements mm_repository.UserDBRepository
func (mmGetUsers *UserDBRepositoryMock) GetUsers(ctx context.Context, params *model.GetUsersRequest) (upa1 []*model.UserInfo, err error) {
	mm_atomic.AddUint64(&mmGetUsers.beforeGetUsersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUsers.afterGetUsersCounter, 1)

	mmGetUsers.t.Helper()

	if mmGetUsers.inspectFuncGetUsers != nil {
		mmGetUsers.inspectFuncGetUsers(ctx, params)
	}

	mm_params := UserDBRepositoryMockGetUsersParams{ctx, params}

	// Record call args
	mmGetUsers.GetUsersMock.mutex.Lock()
	mmGetUsers.GetUsersMock.callArgs = append(mmGetUsers.GetUsersMock.callArgs, &mm_params)
	mmGetUsers.GetUsersMock.mutex.Unlock()

	for _, e := range mmGetUsers.GetUsersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.upa1, e.results.err
		}
	}

	if mmGetUsers.GetUsersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUsers.GetUsersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUsers.GetUsersMock.defaultExpectation.params
		mm_want_ptrs := mmGetUsers.GetUsersMock.defaultExpectation.paramPtrs

		mm_got := UserDBRepositoryMockGetUsersParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUsers.t.Errorf("UserDBRepositoryMock.GetUsers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUsers.GetUsersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmGetUsers.t.Errorf("UserDBRepositoryMock.GetUsers got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUsers.GetUsersMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUsers.t.Errorf("UserDBRepositoryMock.GetUsers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUsers.GetUsersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUsers.GetUsersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUsers.t.Fatal("No results are set for the UserDBRepositoryMock.GetUsers")
		}
		return (*mm_results).upa1, (*mm_results).err
	}
	if mmGetUsers.funcGetUsers != nil {
		return mmGetUsers.funcGetUsers(ctx, params)
	}
	mmGetUsers.t.Fatalf("Unexpected call to UserDBRepositoryMock.GetUsers. %v %v", ctx, params)
	return
}

// GetUsersAfterCounter returns a count of finished UserDBRepositoryMock.GetUsers invocations
func (mmGetUsers *UserDBRepositoryMock) GetUsersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUsers.afterGetUsersCounter)
}

// GetUsersBeforeCounter returns a count of UserDBRepositoryMock.GetUsers invocations
func (mmGetUsers *UserDBRepositoryMock) GetUsersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUsers.beforeGetUsersCounter)
}

// Calls returns a list of arguments used in each call to UserDBRepositoryMock.GetUsers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUsers *mUserDBRepositoryMockGetUsers) Calls() []*UserDBRepositoryMockGetUsersParams {
	mmGetUsers.mutex.RLock()

	argCopy := make([]*UserDBRepositoryMockGetUsersParams, len(mmGetUsers.callArgs))
	copy(argCopy, mmGetUsers.callArgs)

	mmGetUsers.mutex.RUnlock()

	return argCopy
}

// MinimockGetUsersDone returns true if the count of the GetUsers invocations corresponds
// the number of defined expectations
func (m *UserDBRepositoryMock) MinimockGetUsersDone() bool {
	if m.GetUsersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUsersMock.invocationsDone()
}

// MinimockGetUsersInspect logs each unmet expectation
func (m *UserDBRepositoryMock) MinimockGetUsersInspect() {
	for _, e := range m.GetUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserDBRepositoryMock.GetUsers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUsersCounter := mm_atomic.LoadUint64(&m.afterGetUsersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUsersMock.defaultExpectation != nil && afterGetUsersCounter < 1 {
		if m.GetUsersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserDBRepositoryMock.GetUsers at\n%s", m.GetUsersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserDBRepositoryMock.GetUsers at\n%s with params: %#v", m.GetUsersMock.defaultExpectation.expectationOrigins.origin, *m.GetUsersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUsers != nil && afterGetUsersCounter < 1 {
		m.t.Errorf("Expected call to UserDBRepositoryMock.GetUsers at\n%s", m.funcGetUsersOrigin)
	}

	if !m.GetUsersMock.invocationsDone() && afterGetUsersCounter > 0 {
		m.t.Errorf("Expected %d calls to UserDBRepositoryMock.GetUsers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUsersMock.expectedInvocations), m.GetUsersMock.expectedInvocationsOrigin, afterGetUsersCounter)
	}
}

type mUserDBRepositoryMockUpdate struct {
	optional           bool
	mock               *UserDBRepositoryMock
	defaultExpectation *UserDBRepositoryMockUpdateExpectation
	expectations       []*UserDBRepositoryMockUpdateExpectation

	callArgs []*UserDBRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserDBRepositoryMockUpdateExpectation specifies expectation struct of the UserDBRepository.Update
type UserDBRepositoryMockUpdateExpectation struct {
	mock               *UserDBRepositoryMock
	params             *UserDBRepositoryMockUpdateParams
	paramPtrs          *UserDBRepositoryMockUpdateParamPtrs
	expectationOrigins UserDBRepositoryMockUpdateExpectationOrigins
	results            *UserDBRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// UserDBRepositoryMockUpdateParams contains parameters of the UserDBRepository.Update
type UserDBRepositoryMockUpdateParams struct {
	ctx      context.Context
	id       int64
	userInfo *model.UpdateUserInfo
}

// UserDBRepositoryMockUpdateParamPtrs contains pointers to parameters of the UserDBRepository.Update
type UserDBRepositoryMockUpdateParamPtrs struct {
	ctx      *context.Context
	id       *int64
	userInfo **model.UpdateUserInfo
}

// UserDBRepositoryMockUpdateResults contains results of the UserDBRepository.Update
type UserDBRepositoryMockUpdateResults struct {
	err error
}

// UserDBRepositoryMockUpdateOrigins contains origins of expectations of the UserDBRepository.Update
type UserDBRepositoryMockUpdateExpectationOrigins struct {
	origin         string
	originCtx      string
	originId       string
	originUserInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mUserDBRepositoryMockUpdate) Optional() *mUserDBRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for UserDBRepository.Update
func (mmUpdate *mUserDBRepositoryMockUpdate) Expect(ctx context.Context, id int64, userInfo *model.UpdateUserInfo) *mUserDBRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserDBRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserDBRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("UserDBRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &UserDBRepositoryMockUpdateParams{ctx, id, userInfo}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for UserDBRepository.Update
func (mmUpdate *mUserDBRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mUserDBRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserDBRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserDBRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserDBRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserDBRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectIdParam2 sets up expected param id for UserDBRepository.Update
func (mmUpdate *mUserDBRepositoryMockUpdate) ExpectIdParam2(id int64) *mUserDBRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserDBRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserDBRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserDBRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserDBRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.id = &id
	mmUpdate.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectUserInfoParam3 sets up expected param userInfo for UserDBRepository.Update
func (mmUpdate *mUserDBRepositoryMockUpdate) ExpectUserInfoParam3(userInfo *model.UpdateUserInfo) *mUserDBRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserDBRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserDBRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("UserDBRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &UserDBRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.userInfo = &userInfo
	mmUpdate.defaultExpectation.expectationOrigins.originUserInfo = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the UserDBRepository.Update
func (mmUpdate *mUserDBRepositoryMockUpdate) Inspect(f func(ctx context.Context, id int64, userInfo *model.UpdateUserInfo)) *mUserDBRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for UserDBRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by UserDBRepository.Update
func (mmUpdate *mUserDBRepositoryMockUpdate) Return(err error) *UserDBRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserDBRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &UserDBRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &UserDBRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the UserDBRepository.Update method
func (mmUpdate *mUserDBRepositoryMockUpdate) Set(f func(ctx context.Context, id int64, userInfo *model.UpdateUserInfo) (err error)) *UserDBRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the UserDBRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the UserDBRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the UserDBRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mUserDBRepositoryMockUpdate) When(ctx context.Context, id int64, userInfo *model.UpdateUserInfo) *UserDBRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("UserDBRepositoryMock.Update mock is already set by Set")
	}

	expectation := &UserDBRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &UserDBRepositoryMockUpdateParams{ctx, id, userInfo},
		expectationOrigins: UserDBRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up UserDBRepository.Update return parameters for the expectation previously defined by the When method
func (e *UserDBRepositoryMockUpdateExpectation) Then(err error) *UserDBRepositoryMock {
	e.results = &UserDBRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times UserDBRepository.Update should be invoked
func (mmUpdate *mUserDBRepositoryMockUpdate) Times(n uint64) *mUserDBRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of UserDBRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mUserDBRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.UserDBRepository
func (mmUpdate *UserDBRepositoryMock) Update(ctx context.Context, id int64, userInfo *model.UpdateUserInfo) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, id, userInfo)
	}

	mm_params := UserDBRepositoryMockUpdateParams{ctx, id, userInfo}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := UserDBRepositoryMockUpdateParams{ctx, id, userInfo}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("UserDBRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdate.t.Errorf("UserDBRepositoryMock.Update got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.userInfo != nil && !minimock.Equal(*mm_want_ptrs.userInfo, mm_got.userInfo) {
				mmUpdate.t.Errorf("UserDBRepositoryMock.Update got unexpected parameter userInfo, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originUserInfo, *mm_want_ptrs.userInfo, mm_got.userInfo, minimock.Diff(*mm_want_ptrs.userInfo, mm_got.userInfo))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("UserDBRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the UserDBRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, id, userInfo)
	}
	mmUpdate.t.Fatalf("Unexpected call to UserDBRepositoryMock.Update. %v %v %v", ctx, id, userInfo)
	return
}

// UpdateAfterCounter returns a count of finished UserDBRepositoryMock.Update invocations
func (mmUpdate *UserDBRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of UserDBRepositoryMock.Update invocations
func (mmUpdate *UserDBRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to UserDBRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mUserDBRepositoryMockUpdate) Calls() []*UserDBRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*UserDBRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *UserDBRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *UserDBRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserDBRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserDBRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserDBRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to UserDBRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to UserDBRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserDBRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockGetUsersInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserDBRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserDBRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetUsersDone() &&
		m.MinimockUpdateDone()
}
